void
write_Cfunc(const char *name, int argc, char **argv, Coll * ex, Coll * nm)
{
   char buf[1024 * 8];

   char word1[80], word2[80], word3[80];

   int i, use_asm = 0, count;

   FILE *in = 0, *out = 0;

   int shared = shared_flag || eshared_flag;

   time_t tbuf;

   Coll names;

   Coll fnames;

   Coll dnames;

   Coll rnames;

   Coll objs;

   Coll libs;

   Coll nlibs, slibs;

   Coll alibs;

   int labn, labcn;

   init_Coll(&names, free, strcmp);
   init_Coll(&fnames, free, 0 /*strcmp */ );
   init_Coll(&dnames, free, strcmp);
   init_Coll(&rnames, free, strcmp);
   init_Coll(&objs, free, 0);
   init_Coll(&libs, free, 0);
   init_Coll(&nlibs, free, 0);
   init_Coll(&slibs, 0, strcmp);
   init_Coll(&alibs, 0, 0);

   strcpy(buf, NM_PRG);

   for (i = 0; i < argc; i++)
   {
      char *a = argv[i];

      if (a[0] == '-' && a[1] == 'l')
      {
	 char path[256];

	 snprintf(path, sizeof(path), "%s/lib/lib%s%s", CLIPROOT, a + 2, SLIBSUF);
	 if (!access(path, R_OK))
	    append_Coll(&libs, strdup(path));

	 continue;
      }
      if (a[0] == '-')
      {
	 continue;
      }
      if (strsuff(a, SLIBSUF) || strsuff(a, LIBSUF))
      {
	 if (a[0] == '/' || (a[0] == '.' && a[1] == '/') || (a[0] == '.' && a[1] == '.' && a[2] == '/'))
	 {
	    append_Coll(&libs, strdup(a));
	 }
	 else
	 {
	    char path[256];

	    snprintf(path, sizeof(path), "%s/lib/%s", CLIPROOT, a);
	    if (!access(path, R_OK))
	       append_Coll(&libs, strdup(path));
	 }
      }
      else if (strsuff(a, SOBJSUF) || strsuff(a, OBJSUF))
	 append_Coll(&objs, strdup(a));
   }

   for (i = libs.count_of_Coll - 1; i >= 0; i--)
   {
		char *s = (char *) libs.items_of_Coll[i];

      char *e, *r, *b;

      int l, j, ind, isA = 0;

      e = strsuff(s, SLIBSUF);

      if (!e)
      {
	 e = strsuff(s, LIBSUF);
	 isA = 1;
      }
      b = strrchr(s, '/');
      if (!b)
	 b = s;
      else
	 b++;
      if (e && e > b + 1)
	 l = e - b;
      else
	 l = strlen(b);
      r = (char *) malloc(l + 1);
      for (j = 0; j < l; j++)
      {
	 switch (b[j])
	 {
	 case '-':
	    r[j] = '_';
	    break;
	 default:
	    r[j] = b[j];
	    break;
	 }
      }
      r[l] = 0;
      if (!search_Coll(&slibs, s, &ind))
      {
	 insert_Coll(&slibs, r);
	 if (isA)
	 {
	    append_Coll(&alibs, s);
	    free(r);
	 }
	 else
	    append_Coll(&nlibs, r);
      }
      else
	 free(r);

      read_names(s, ex, nm);
   }

   if (!shared)
   {
		for (i = 0; i < libs.count_of_Coll; i++)
      {
			char *s = (char *) libs.items_of_Coll[i];

	 strcat(buf, " ");
	 strcat(buf, s);
      }
   }
   else
   {
		for (i = 0; i < alibs.count_of_Coll; i++)
      {
			char *s = (char *) alibs.items_of_Coll[i];

	 strcat(buf, " ");
	 strcat(buf, s);
      }
   }

   for (i = 0; i < objs.count_of_Coll; i++)
   {
		char *s = (char *) objs.items_of_Coll[i];

      strcat(buf, " ");
      strcat(buf, s);

      read_names(s, ex, nm);
   }

   v_printf(2, "%s\n", buf);

   in = popen(buf, "r");

   if (!in)
   {
      yyerror("cannot open pipe '%s'", buf);
      goto end;
   }

#ifdef USE_AS
   {
      char *s = strrchr(name, '.');

      if (asm_flag && s && !strcmp(s, ".s"))
	 use_asm = 1;
   }
#endif

   out = fopen(name, "wb");
   if (!out)
   {
      yyerror("cannot open output file '%s'", name);
      goto end;
   }

   fprintf(out, "/*\n");
   fprintf(out, " *\tautomatically generated by clip-");
   printVersion(out);
   fprintf(out, "\n");
   time(&tbuf);
   fprintf(out, " *\tat %s", ctime(&tbuf));
   fprintf(out, " *\tfrom sources:\n");
   for (i = 0; i < argc; ++i)
      fprintf(out, " *\t%s\n", argv[i]);
   fprintf(out, " */\n");

   if (!use_asm)
   {
      fprintf(out, "\n#include \"ci_clip.h\"\n");
   }
   else
   {
      fprintf(out, "\n\t.file \"%s\"\n", name);
   }

   while (fgets(buf, sizeof(buf), in) != NULL)
   {
      char *s, *sp;

      int br;

      int n = sscanf(buf, "%s %s %s", word1, word2, word3);

      int l;

      if (n == 3)
      {
	 if (!strcmp(word2, "T"))
	    br = 1;
	 else if (!strcmp(word2, "D"))
	    br = 2;
	 else
	    continue;
	 sp = word3;
      }
      else if (n == 2)
      {
	 if (strcmp(word1, "U"))
	    continue;
	 sp = word2;
	 br = 3;
      }
      else
	 continue;
#ifdef NM_UNDERSCORE
      sp++;
#endif
      l = strlen(sp);
      if (l < 6 || memcmp(sp, "clip_", 5))
	 goto next;

      for (s = sp + 5; *s; ++s)
	 if (!isupper(*s) && !isdigit(*s) && *s != '_')
	    goto next;
      if (br == 2)
      {
	 if (!memcmp(sp + 5, "_PCODE_", 7))
	    insert_Coll(&fnames, strdup(sp));
	 else if (!memcmp(sp + 5, "_RDD_", 4))
	    insert_Coll(&dnames, strdup(sp));
	 else if (!memcmp(sp + 5, "_RTTI_", 6))
	    insert_Coll(&rnames, strdup(sp));
      }
      else
	 insert_Coll(&names, strdup(sp));
    next:
      ;
   }
   if (in)
   {
      pclose(in);
      in = 0;
   }

   for (i = 0; i < names.count_of_Coll; ++i)
   {
		VAR(char, s, names.items_of_Coll[i]);

      if (!use_asm)
	 fprintf(out, "ClipFunction %s;\n", s);
      add_name(nm, s);
   }

   if (shared)
   {
		for (i = nlibs.count_of_Coll - 1; i >= 0; i--)
      {
			char *s = (char *) nlibs.items_of_Coll[i];

	 if (!use_asm)
	    fprintf(out, "CLIP_DLLIMPORT ClipFunction *_clip_builtin_%s ( long hash );\n", s);
      }
   }

   labn = 3;
   labcn = 0;
   if (!use_asm)
   {
      fprintf(out, "\nstatic ClipFunction *\n_builtins(long hash)\n{\n");

      if (shared)
      {
	 fprintf(out, "\tClipFunction *rp = 0;\n");
	 for (i = nlibs.count_of_Coll - 1; i >= 0; i--)
	 {
		 char *s = (char *) nlibs.items_of_Coll[i];

	    fprintf(out, "\trp = _clip_builtin_%s ( hash );\n", s);
	    fprintf(out, "\tif ( rp )\n\t\treturn rp;\n");
	 }
      }

      fprintf(out, "\n\tswitch( hash )\n\t{\n");
		for (i = 0; i < names.count_of_Coll; ++i)
      {
			VAR(char, s, names.items_of_Coll[i]);

	 if (!memcmp(s + 5, "INIT_", 5) || !memcmp(s + 5, "EXIT_", 5))
	    continue;
	 fprintf(out, "\tcase %ld:\n", (long) hashstr(s + 5));
	 fprintf(out, "\t\treturn %s;\n", s);
      }
      fprintf(out, "\tdefault:\n\t\treturn 0;\n");
      fprintf(out, "\t}\n");
      fprintf(out, "};\n\n");
   }
   else
   {

      fprintf(out, ".text\n\t.align 4\n");
/*		fprintf(out, "\t.type\t_builtins,@function\n");*/
      fprintf(out, US "_builtins:\n");

      fprintf(out, "\tpushl %%ebp\n");
      fprintf(out, "\tmovl %%esp,%%ebp\n");
#ifdef _WIN32
      fprintf(out, "\tsubl $36,%%esp\n");
      fprintf(out, "\tpushl %%ebx\n");
#else
      fprintf(out, "\tsubl $24,%%esp\n");
#endif
      fprintf(out, "\tmovl $0,-4(%%ebp)\n");

      if (shared)
      {
			for (i = nlibs.count_of_Coll - 1; i >= 0; i--)
	 {
		 char *s = (char *) nlibs.items_of_Coll[i];

	    fprintf(out, "\taddl $-12,%%esp\n");
	    fprintf(out, "\tmovl 8(%%ebp),%%eax\n");
	    fprintf(out, "\tpushl %%eax\n");
#ifdef _WIN32
	    fprintf(out, "\tmovl %s%s_clip_builtin_%s, %%ebx\n", IMP, US, s);
	    fprintf(out, "\tcall *%%ebx\n");
#else
	    fprintf(out, "\tcall %s%s_clip_builtin_%s\n", IMP, US, s);
#endif
	    fprintf(out, "\taddl $16,%%esp\n");
	    fprintf(out, "\tmovl %%eax,%%eax\n");
	    fprintf(out, "\tmovl %%eax,-4(%%ebp)\n");
	    fprintf(out, "\tcmpl $0,-4(%%ebp)\n");
	    fprintf(out, "\tje .L%d\n", labn);
	    fprintf(out, "\tmovl -4(%%ebp),%%edx\n");
	    fprintf(out, "\tmovl %%edx,%%eax\n");
	    fprintf(out, "\tjmp .L2\n");
	    fprintf(out, "\t.p2align 4,,7\n");
	    fprintf(out, ".L%d:\n", labn);
	    labn++;
	 }
      }
            if (names.count_of_Coll)
      {
	 /* tree create */
	 Coll tree;

	 int i;

	 init_Coll(&tree, free, cmp_Label);

	 fprintf(out, "\tmovl 8(%%ebp),%%eax\n");

	 for (i = 0; i < names.count_of_Coll; i++)
		 insert_Coll(&tree, new_Label((char *) (names.items_of_Coll[i])));

	 for (i = 0; i < tree.count_of_Coll; i++)
		 ((Label *) (tree.items_of_Coll[i]))->branch_of_Label = labn++;
	 for (i = 0; i < tree.count_of_Coll; i++)
		 ((Label *) (tree.items_of_Coll[i]))->label_of_Label = labn++;

	 print_tree(out, &tree, 0, names.count_of_Coll - 1);
	 print_labels(out, &tree);

	 destroy_Coll(&tree);
      }
      fprintf(out, "\t.p2align 4,,7\n");
      fprintf(out, ".L1:\n");
      fprintf(out, "\txorl %%eax,%%eax\n");
      fprintf(out, "\tjmp .L2\n");
      fprintf(out, "\t.p2align 4,,7\n");
      fprintf(out, ".L2:\n");
#ifdef _WIN32
      fprintf(out, "\tmovl -40(%%ebp),%%ebx\n");
      fprintf(out, "\tmovl %%ebp,%%esp\n");
      fprintf(out, "\tpopl %%ebp\n");
#else
      fprintf(out, "\tleave\n");
#endif
      fprintf(out, "\tret\n");

      fprintf(out, ".L%d:\n", labn);
/*		fprintf(out, "\t.size\t_builtins,.L%d-_builtins\n", labn);*/
      labn++;

   }

   if (!use_asm)
   {
      fprintf(out, "\nstatic ClipFunction *_inits[]=\n{\n");
   }
   else
   {
      fprintf(out, ".data\n");
      fprintf(out, "\t.align 4\n");
/*		fprintf(out, "\t.type\t_inits,@object\n");*/
      fprintf(out, US "_inits:\n");
   }

   /* CLIPINIT, if defined, _must_ be first */
   count = 0;
	for (i = 0; i < names.count_of_Coll; ++i)
   {
		VAR(char, s, names.items_of_Coll[i]);

      if (strcmp(s + 5, "INIT_CLIPINIT"))
	 continue;
      if (!use_asm)
	 fprintf(out, "\t%s,\n", s);
      else
	 fprintf(out, "\t.long %s%s\n", US, s);
      count++;
   }
      for (i = 0; i < names.count_of_Coll; ++i)
   {
		VAR(char, s, names.items_of_Coll[i]);

      if (memcmp(s + 5, "INIT_", 5) || !strcmp(s + 5, "INIT_CLIPINIT"))
	 continue;
      if (!use_asm)
	 fprintf(out, "\t%s,\n", s);
      else
	 fprintf(out, "\t.long %s%s\n", US, s);
      count++;
   }
   if (!use_asm)
   {
      fprintf(out, "\t0,\n");
      fprintf(out, "};\n\n");
   }
   else
   {
      fprintf(out, "\t.long 0\n");
/*		fprintf(out, "\t.size _inits,%d\n", (count + 1) * sizeof(ClipFunction *));*/
   }

   if (!use_asm && shared)
   {
		for (i = 0; i < nlibs.count_of_Coll; ++i)
      {
			VAR(char, s, nlibs.items_of_Coll[i]);

	 fprintf(out, "CLIP_DLLIMPORT extern ClipFunction **_libinits_%s;\n", s);
      }
   }

   if (!use_asm)
      fprintf(out, "\nstatic ClipFunction ***_libinits[]=\n{\n");
   else
   {
      fprintf(out, "\t.align 4\n");
/*		fprintf(out, "\t.type\t_libinits,@object\n");*/
      fprintf(out, US "_libinits:\n");
   }

   if (shared)
   {
		for (i = 0; i < nlibs.count_of_Coll; ++i)
      {
	 if (!use_asm)
	    fprintf(out, "\t0,\n");
	 else
	    fprintf(out, "\t.long 0\n");
      }
   }
   if (!use_asm)
   {
      fprintf(out, "\t0,\n");
      fprintf(out, "};\n\n");
   }
   else
   {
      fprintf(out, "\t.long 0\n");
/*		fprintf(out, "\t.size _libinits,%d\n", ((shared ? nlibs.count : 0) + 1) * sizeof(ClipFunction ***));*/
   }

   if (!use_asm)
   {
      fprintf(out, "\nstatic ClipFunction *_exits[]=\n{\n");
   }
   else
   {
      fprintf(out, "\t.align 4\n");
/*		fprintf(out, "\t.type\t_exits,@object\n");*/
      fprintf(out, US "_exits:\n");
   }

   count = 0;
	for (i = 0; i < names.count_of_Coll; ++i)
   {
		VAR(char, s, names.items_of_Coll[i]);

      if (memcmp(s + 5, "EXIT_", 5))
	 continue;
      if (!use_asm)
	 fprintf(out, "\t%s,\n", s);
      else
	 fprintf(out, "\t.long %s\n", s);
      count++;
   }
   if (!use_asm)
   {
      fprintf(out, "\t0\n");
      fprintf(out, "};\n\n");
   }
   else
   {
      fprintf(out, "\t.long 0\n");
/*		fprintf(out, "\t.size _exits,%d\n", (count + 1) * sizeof(ClipFunction *));*/
   }

   if (!use_asm && shared)
   {
		for (i = 0; i < nlibs.count_of_Coll; ++i)
      {
			VAR(char, s, nlibs.items_of_Coll[i]);

	 fprintf(out, "CLIP_DLLIMPORT extern ClipFunction **_libexits_%s;\n", s);
      }
   }
   if (!use_asm)
      fprintf(out, "\nstatic ClipFunction ***_libexits[]=\n{\n");
   else
   {
      fprintf(out, "\t.align 4\n");
/*		fprintf(out, "\t.type\t_libexits,@object\n");*/
      fprintf(out, US "_libexits:\n");
   }

   if (shared)
   {
		for (i = 0; i < nlibs.count_of_Coll; ++i)
      {
	 if (!use_asm)
	    fprintf(out, "\t0,\n");
	 else
	    fprintf(out, "\t.long 0\n");
      }
   }
   if (!use_asm)
   {
      fprintf(out, "\t0,\n");
      fprintf(out, "};\n\n");
   }
   else
   {
      fprintf(out, "\t.long 0\n");
/*		fprintf(out, "\t.size _libexits,%d\n", (nlibs.count + 1) * sizeof(ClipFunction ***));*/
   }

   if (!use_asm)
      fprintf(out, "\nstatic const char *_pfunctions[]=\n{\n");
   else
   {
      fprintf(out, "\t.align 4\n");
/*		fprintf(out, "\t.type\t_pfunctions,@object\n");*/
/*		fprintf(out, "\t.size\t_pfunctions,%d\n", (poName.count + paName.count + 1) * sizeof(char *));*/
      fprintf(out, US "_pfunctions:\n");
   }
   count = 0;
	for (i = 0; i < poName.count_of_Coll; ++i)
   {
		VAR(char, name, poName.items_of_Coll[i]);

      if (!use_asm)
	 fprintf(out, "\t\"%s\",\n", name);
      else
	 fprintf(out, "\t.long .LC%d\n", labcn + count);
      count++;
   }
      for (i = 0; i < paName.count_of_Coll; ++i)
   {
		VAR(char, name, paName.items_of_Coll[i]);

      if (!use_asm)
	 fprintf(out, "\t\"%s\",\n", name);
      else
	 fprintf(out, "\t.long .LC%d\n", labcn + count);
      count++;
   }
   if (!use_asm)
   {
      fprintf(out, "\t0\n");
      fprintf(out, "};\n\n");
   }
   else
   {
      fprintf(out, "\t.long 0\n");
      if (count)
      {
	 fprintf(out, ".section\t.rodata\n");
	 count = 0;
	 for (i = 0; i < poName.count_of_Coll; ++i)
	 {
		 VAR(char, name, poName.items_of_Coll[i]);

	    fprintf(out, ".LC%d:\n\t.string \"%s\"\n", labcn + count, name);
	    count++;
	 }
	 	 for (i = 0; i < paName.count_of_Coll; ++i)
	 {
		 VAR(char, name, paName.items_of_Coll[i]);

	    fprintf(out, ".LC%d:\n\t.string \"%s\"\n", labcn + count, name);
	    count++;
	 }
	 fprintf(out, ".data\n");
	 labcn += count;
      }
   }

   if (!use_asm)
   {
		for (i = 0; i < fnames.count_of_Coll; ++i)
      {
			VAR(char, s, fnames.items_of_Coll[i]);

	 fprintf(out, "extern ClipFile %s;\n", s);
      }
   }

   if (!use_asm)
   {
      fprintf(out, "\nstatic struct ClipFile *_cpfiles[]=\n");
      fprintf(out, "{\n");
   }
   else
   {
      fprintf(out, "\t.align 4\n");
/*		fprintf(out, "\t.type\t_cpfiles,@object\n");*/
      fprintf(out, US "_cpfiles:\n");
   }

   for (i = 0; i < fnames.count_of_Coll; ++i)
   {
		VAR(char, s, fnames.items_of_Coll[i]);

      if (!use_asm)
	 fprintf(out, "\t&%s,\n", s);
      else
	 fprintf(out, "\t.long %s%s\n", US, s);
   }
   if (!use_asm)
   {
      fprintf(out, "\t0\n");
      fprintf(out, "};\n\n");
   }
   else
   {
      fprintf(out, "\t.long 0\n");
/*		fprintf(out, "\t.size _cpfiles,%d\n", (fnames.count + 1) * sizeof(ClipFile *));*/
   }

   if (!use_asm && shared)
   {
		for (i = 0; i < nlibs.count_of_Coll; ++i)
      {
			VAR(char, s, nlibs.items_of_Coll[i]);

	 fprintf(out, "CLIP_DLLIMPORT extern ClipFile **_libcpfiles_%s;\n", s);
      }
   }
   if (!use_asm)
      fprintf(out, "\nstatic ClipFile ***_libcpfiles[]=\n{\n");
   else
   {
      fprintf(out, "\t.align 4\n");
/*		fprintf(out, "\t.type\t_libcpfiles,@object\n");*/
      fprintf(out, US "_libcpfiles:\n");
   }
   if (shared)
   {
		for (i = 0; i < nlibs.count_of_Coll; ++i)
      {
	 if (!use_asm)
	    fprintf(out, "\t0,\n");
	 else
	    fprintf(out, "\t.long 0\n");
      }
   }
   if (!use_asm)
   {
      fprintf(out, "\t0,\n");
      fprintf(out, "};\n\n");
   }
   else
   {
      fprintf(out, "\t.long 0\n");
/*		fprintf(out, "\t.size _cpfiles,%d\n", ((shared ? nlibs.count : 0) + 1) * sizeof(ClipFile *));*/
   }

   if (!use_asm)
   {
		for (i = 0; i < dnames.count_of_Coll; ++i)
      {
			VAR(char, s, dnames.items_of_Coll[i]);

	 fprintf(out, "extern struct DBFuncTable %s;\n", s);
      }
   }

   if (!use_asm)
   {
      fprintf(out, "\nstatic struct DBFuncTable *_dbdrivers[]=\n");
      fprintf(out, "{\n");
   }
   else
   {
      fprintf(out, "\t.align 4\n");
/*		fprintf(out, "\t.type\t_dbdrivers,@object\n");*/
      fprintf(out, US "_dbdrivers:\n");
   }

   for (i = 0; i < dnames.count_of_Coll; ++i)
   {
		VAR(char, s, dnames.items_of_Coll[i]);

      if (!use_asm)
	 fprintf(out, "\t&%s,\n", s);
      else
	 fprintf(out, "\t.long %s\n", s);
   }

   if (!use_asm)
   {
      fprintf(out, "\t0\n");
      fprintf(out, "};\n\n");
   }
   else
   {
      fprintf(out, "\t.long 0\n");
/*		fprintf(out, "\t.size _dbdrivers,%d\n", (dnames.count + 1) * sizeof(DBFuncTable *));*/
   }

   if (!use_asm)
   {
		for (i = 0; i < rnames.count_of_Coll; ++i)
      {
			VAR(char, s, rnames.items_of_Coll[i]);

	 fprintf(out, "extern struct ClipObjRtti %s;\n", s);
      }

      fprintf(out, "\nstatic struct ClipObjRtti *_objrtti[]=\n");
      fprintf(out, "{\n");
   }
   else
   {
      fprintf(out, "\t.align 4\n");
/*		fprintf(out, "\t.type\t_objrtti,@object\n");*/
      fprintf(out, US "_objrtti:\n");
   }

   for (i = 0; i < rnames.count_of_Coll; ++i)
   {
		VAR(char, s, rnames.items_of_Coll[i]);

      if (!use_asm)
	 fprintf(out, "\t&%s,\n", s);
      else
	 fprintf(out, "\t.long %s\n", s);
   }
   if (!use_asm)
   {
      fprintf(out, "\t0\n");
      fprintf(out, "};\n\n");
   }
   else
   {
      fprintf(out, "\t.long 0\n");
/*		fprintf(out, "\t.size _objrtti,%d\n", (rnames.count + 1) * sizeof(ClipObjRtti *));*/
   }

   if (!use_asm)
   {
      fprintf(out, "static ClipInitStruct _init_struct =\n{\n");
      fprintf(out, "\t_builtins,\n");
      fprintf(out, "\t_inits,\n\t_libinits,\n\t_exits,\n\t_libexits,\n\t_pfunctions,\n");
      fprintf(out, "\t_cpfiles,\n\t_libcpfiles,\n\t_objrtti,\n\t(void**)_dbdrivers,\n");
      fprintf(out, "\t\"%s\"\n", targetCharset);
      fprintf(out, "};\n\n");
      fprintf(out, "%svoid _clip_init_struct(ClipInitStruct *sp);\n", shared ? "CLIP_DLLIMPORT " : "");
      fprintf(out, "void\n_clip_init_dll(void)\n{\n");
      if (shared)
      {
			for (i = 0; i < nlibs.count_of_Coll; ++i)
	 {
		 VAR(char, s, nlibs.items_of_Coll[i]);

	    fprintf(out, "\t_libinits[%d] = &_libinits_%s,\n", i, s);
	    fprintf(out, "\t_libexits[%d] = &_libexits_%s,\n", i, s);
	    fprintf(out, "\t_libcpfiles[%d] = &_libcpfiles_%s,\n", i, s);
	 }
      }
      fprintf(out, "\t_clip_init_struct(&_init_struct);\n");
      fprintf(out, "}\n\n");
   }
   else
   {
/*		fprintf(out, "\t.type\t_init_struct,@object\n");*/
/*		fprintf(out, "\t.size\t_init_struct,%d\n", sizeof(ClipInitStruct));*/
      fprintf(out, US "_init_struct:\n");

      fprintf(out, "\t.long %s_builtins\n", US);
      fprintf(out, "\t.long %s_inits\n", US);
      fprintf(out, "\t.long %s_libinits\n", US);
      fprintf(out, "\t.long %s_exits\n", US);
      fprintf(out, "\t.long %s_libexits\n", US);
      fprintf(out, "\t.long %s_pfunctions\n", US);
      fprintf(out, "\t.long %s_cpfiles\n", US);
      fprintf(out, "\t.long %s_libcpfiles\n", US);
      fprintf(out, "\t.long %s_objrtti\n", US);
      fprintf(out, "\t.long %s_dbdrivers\n", US);
      fprintf(out, "\t.long .LC%d\n", labcn);

      fprintf(out, ".section\t.rodata\n");
      fprintf(out, ".LC%d:\n\t.string \"%s\"\n", labcn, targetCharset);
      labcn++;

      fprintf(out, ".text\n");
      fprintf(out, "\t.align 4\n");
      fprintf(out, ".globl %s_clip_init_dll\n", US);
/*		fprintf(out, "\t.type _clip_init_dll,@function\n");*/
      fprintf(out, US "_clip_init_dll:\n");

      fprintf(out, "\tpushl %%ebp\n");
      fprintf(out, "\tmovl %%esp,%%ebp\n");
#ifdef _WIN32
      fprintf(out, "\tsubl $20,%%esp\n");
      fprintf(out, "\tpushl %%ebx\n");
#else
      fprintf(out, "\tsubl $8,%%esp\n");
#endif
      if (shared)
      {
			for (i = 0; i < nlibs.count_of_Coll; ++i)
	 {
		 VAR(char, s, nlibs.items_of_Coll[i]);

#ifdef _WIN32
	    fprintf(out, "\tmovl %s%s_libinits_%s,%%eax\n", IMP, US, s);
	    fprintf(out, "\tmovl %%eax,%s_libinits+%d\n", US, i * sizeof(ClipFunction ***));

	    fprintf(out, "\tmovl %s%s_libexits_%s,%%eax\n", IMP, US, s);
	    fprintf(out, "\tmovl %%eax,%s_libexits+%d\n", US, i * sizeof(ClipFunction ***));

	    fprintf(out, "\tmovl %s%s_libcpfiles_%s,%%eax\n", IMP, US, s);
	    fprintf(out, "\tmovl %%eax,%s_libcpfiles+%d\n", US, i * sizeof(ClipFile ***));
#else
	    fprintf(out, "\tmovl $%s%s_libinits_%s,%s_libinits+%ld\n", IMP, US, s, US, (long) (i * sizeof(ClipFunction ***)));
	    fprintf(out, "\tmovl $%s%s_libexits_%s,%s_libexits+%ld\n", IMP, US, s, US, (long) (i * sizeof(ClipFunction ***)));
	    fprintf(out, "\tmovl $%s%s_libcpfiles_%s,%s_libcpfiles+%ld\n", IMP, US, s, US, (long) (i * sizeof(ClipFile ***)));
#endif
	 }
      }
      fprintf(out, "\taddl $-12,%%esp\n");
      fprintf(out, "\tpushl $%s_init_struct\n", US);
      fprintf(out, "\tcall %s_clip_init_struct\n", US);
      fprintf(out, "\taddl $16,%%esp\n");
#ifdef _WIN32
      fprintf(out, "\tmovl -24(%%ebp),%%ebx\n");
      fprintf(out, "\tmovl %%ebp,%%esp\n");
      fprintf(out, "\tpopl %%ebp\n");
#else
      fprintf(out, "\tleave\n");
#endif
      fprintf(out, "\tret\n");
      fprintf(out, ".L%d:\n", labn);
/*		fprintf(out, "\t.size	 _clip_init_dll,.L%d-_clip_init_dll\n", labn);*/
      labn++;
   }

   if ((pcode_flag || pc_flag || !main_flag) && !wrote_main)
   {

      if (!use_asm)
      {
	 fprintf(out, "\n\
\n\
extern char **environ;\n\
\n\
int\n\
main(int argc, char **argv)\n\
{\n\
	ClipMachine *mp;\n\
	_clip_init_dll();\n\
	Task_INIT();\n\
\n\
	mp = new_ClipMachine(0);\n\
	return _clip_main(mp, %ld, argc, argv, environ);\n\
}\n\
", (long) hashstr("MAIN"));

      }
      else
      {
	 fprintf(out, "\t.align 4\n");
	 fprintf(out, ".globl %smain\n", US);
/*			fprintf(out, "\t.type	 main,@function\n");*/
	 fprintf(out, US "main:\n");
	 fprintf(out, "\tpushl %%ebp\n");
	 fprintf(out, "\tmovl %%esp,%%ebp\n");
	 fprintf(out, "\tsubl $24,%%esp\n");
#ifdef _WIN32
	 fprintf(out, "\tcall ___main\n");
#endif
	 fprintf(out, "\tcall %s_clip_init_dll\n", US);
	 fprintf(out, "\taddl $-12,%%esp\n");
	 fprintf(out, "\tpushl $0\n");
	 fprintf(out, "\tcall %snew_ClipMachine\n", US);
	 fprintf(out, "\taddl $16,%%esp\n");
	 fprintf(out, "\tmovl %%eax,-4(%%ebp)\n");
	 fprintf(out, "\taddl $-12,%%esp\n");
	 fprintf(out, "\tmovl %senviron,%%eax\n", US);
	 fprintf(out, "\tpushl %%eax\n");
	 fprintf(out, "\tmovl 12(%%ebp),%%eax\n");
	 fprintf(out, "\tpushl %%eax\n");
	 fprintf(out, "\tmovl 8(%%ebp),%%eax\n");
	 fprintf(out, "\tpushl %%eax\n");
	 fprintf(out, "\tpushl $%ld\n", hashstr("MAIN"));
	 fprintf(out, "\tmovl -4(%%ebp),%%eax\n");
	 fprintf(out, "\tpushl %%eax\n");
	 fprintf(out, "\tcall %s_clip_main\n", US);
	 fprintf(out, "\taddl $32,%%esp\n");
	 fprintf(out, "\tmovl %%eax,%%edx\n");
	 fprintf(out, "\tmovl %%edx,%%eax\n");
	 fprintf(out, "\tjmp .L%d\n", labn);
/*			fprintf(out, "\t.p2align 4,,7\n");*/
	 fprintf(out, "\t.align 4\n");
	 fprintf(out, ".L%d:\n", labn);
	 labn++;
#ifdef _WIN32
	 fprintf(out, "\tmovl %%ebp,%%esp\n");
	 fprintf(out, "\tpopl %%ebp\n");
#else
	 fprintf(out, "\tleave\n");
#endif
	 fprintf(out, "\tret\n");
	 fprintf(out, ".L%d:\n", labn);
/*			fprintf(out, "\t.size	 main,.L%d-main\n", labn);*/

      }
   }

 end:
   if (in)
      pclose(in);
   if (out)
      fclose(out);
   destroy_Coll(&names);
   destroy_Coll(&fnames);
   destroy_Coll(&dnames);
   destroy_Coll(&objs);
   destroy_Coll(&libs);
   destroy_Coll(&nlibs);
   destroy_Coll(&slibs);
   destroy_Coll(&alibs);
}
