ADDLIBS='-L/usr/lib64 -ldl -lm -lgpm -L/usr/local/lib -liconv -lreadline -lncurses'
ADDMAKECMDGOALS=
ADD_CFLAGS=-fPIC
ARCH=x86_64
AS_PRG=as
BASH=/bin/bash
BASH_ARGC=([0]="1" [1]="1" [2]="1")
BASH_ARGV=([0]="/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/init/create.dir.sh" [1]="/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/init/configure.gen.sh" [2]="home")
BASH_LINENO=([0]="787" [1]="47" [2]="0")
BASH_SOURCE=([0]="/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/init/create.dir.sh" [1]="/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/init/configure.gen.sh" [2]="./configure")
BASH_VERSINFO=([0]="3" [1]="2" [2]="48" [3]="2" [4]="release" [5]="x86_64-mandriva-linux-gnu")
BASH_VERSION='3.2.48(2)-release'
BINDIR=/home/angelo/bin
BROWSER=/usr/bin/www-browser
Bban=1
C64=64
CC=gcc
CHECK_STACK=
CLIP=/home/angelo//clip64//bin//clip64
CLIPROOT=/clip64/
CLIP_CONFIGURE_FLAGS=home
CLIP_DLLEXPORT=
CLIP_DLLIMPORT=
CLIP_NAMES=yes
CLIP_ROOT=/home/angelo//clip64/
COLORFGBG='15;0'
CONFIGURE_SH=//sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/init/configure.sh
C_FLAGS='-Wall -fPIC -I/home/angelo//clip64//include/  '
C_LIBS='-L/home/angelo//clip64//lib64/ -lclip'
Clip_B_Dir=/home/angelo//clip64//bin/
Clip_C_Dir=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/config/
Clip_D_Dir=/home/angelo//clip64//doc/
Clip_H_Dir=/sda1/source/compile/my_make.new/x86_64
Clip_I_Dir=/home/angelo//clip64//include/
Clip_L_Dir=/home/angelo//clip64//lib64/
Clip_M_Dir=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64
Clip_S_Dir=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/config//setup/
Clip_T_Dir=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/temp/
CurDir=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64
DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-jpA3V980E5,guid=fbb0259246f6e2e51b7b18d94a5c8195
DEBUGFLAGS=
DESKTOP_SESSION=01KDE4
DESKTOP_STARTUP_ID=
DESTDIR=/home/angelo/
DIRSTACK=()
DISPLAY=:0
DLLIB=-ldl
DLLREALSUFF=.so
DLLSUFF=.so
DM_CONTROL=/var/run/xdmctl
DSSI_PATH=/usr/lib64/dssi
EUID=500
EXESUFF=64
FORCEALIGN=
GCONF_TMPDIR=/tmp
GROUPS=()
GS_LIB=/home/angelo/.fonts
GTK_MODULES=canberra-gtk-module
G_FILENAME_ENCODING=@locale
HAVE_ICONV=yes
HISTCONTROL=ignoredups
HISTSIZE=1000
HOME=/home/angelo
HOSTNAME=x86_64.angelo.girardi.home
HOSTTYPE=x86_64
H_Dir=/home/angelo/
ICONV_INC=/usr/local/include/iconv.h
ICONV_LIB='-L/usr/local/lib -liconv'
IFS=$' \t\n'
INPUTRC=/etc/inputrc
INSTDIR=/home/angelo//clip64/
KDE_FULL_SESSION=true
KDE_SESSION_UID=500
KDE_SESSION_VERSION=4
KONSOLE_DBUS_SERVICE=:1.32
KONSOLE_DBUS_SESSION=/Sessions/2
LADSPA_PATH=/usr/lib64/ladspa/
LANG=en_BE.UTF-8
LANGUAGE=en_BE.UTF-8:en_US:en
LC_ADDRESS=en_BE.UTF-8
LC_COLLATE=en_BE.UTF-8
LC_CTYPE=en_BE.UTF-8
LC_IDENTIFICATION=en_BE.UTF-8
LC_MEASUREMENT=en_BE.UTF-8
LC_MESSAGES=en_BE.UTF-8
LC_MONETARY=en_BE.UTF-8
LC_NAME=en_BE.UTF-8
LC_NUMERIC=en_BE.UTF-8
LC_PAPER=en_BE.UTF-8
LC_SOURCED=1
LC_TELEPHONE=en_BE.UTF-8
LC_TIME=en_BE.UTF-8
LDS_END='-L/usr/lib64 /usr/lib64/crtn.o -lc -lc_pic'
LDS_PRG='ld -Bstatic -L/usr/lib64 /usr/lib64/crt1.o /usr/lib64/crti.o'
LD_END='-L/usr/lib64 /usr/lib64/crtn.o -lc'
LD_PRG='ld -A x86_64 -Bdynamic --dynamic-linker --libexecdir=/usr/lib64 -L/usr/lib64 /lib64/ld-linux-x86_64.so.2 /usr/lib64/crt1.o /usr/lib64/crti.o'
LESS=-MM
LESSCHARSET=utf-8
LESSKEY=/etc/.less
LESSOPEN='|/usr/bin/lesspipe.sh %s'
LOGNAME=angelo
LS_COLORS='rs=0:di=01;34:ln=01;36:hl=44;37:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.xz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz2=01;31:*.tz=01;31:*.tlz=01;31:*.txz=01;31:*.deb=01;31:*.rpm=01;31:*.cpio=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.iso=01;31:*.jpg=01;35:*.jpeg=01;35:*.JPG=01;35:*.JPEG=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.divx=01;35:*.xvid=01;35:*.asf=01;35:*.wmv=01;35:*.mp4=01;35:*.3gp=01;35:*.flv=01;35:*.ico=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:*.mp2=00;36:*.mod=00;36:*.xm=00;36:*.s3m=00;36:*.it=00;36:*.wma=00;36:*~=47;30:*.bak=47;30:*.swp=47;30:*.bck=47;30:*.bk=47;30:*.old=47;30:*.tmp=47;30:*.save=47;30:*.rpmsave=47;30:*.rpmnew=47;30:'
LibDir=/lib64
MACHTYPE=x86_64-mandriva-linux-gnu
MAIL=/var/spool/mail/angelo
MAKE=/usr/bin/gmake
MAKEFLAGS=' --warn-undefined-variables'
MAKELEVEL=1
MALLOC_CHECK_=2
MDBG=
MDV_MENU_STYLE=mandriva
MEMDEBUG_LEVEL=0
META_CLASS=powerpack
MFLAGS='- --warn-undefined-variables'
MLIB=
Makefile_02_in=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/init/Makefile.02.in
Makefile_end_in=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/init/Makefile.end.in
Makefile_o_in=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/init/Makefile.o.in
Making=home
NLSPATH=/usr/share/locale/%l/%N
NM_PRG=nm
NM_UNDERSCORE=
NODBU=yes
NO_GETTEXT=
OLDPWD=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64
OPTERR=1
OPTFLAGS=
OPTIND=1
OSNAME=LINUX
OSTYPE=linux-gnu
OS_LINUX=yes
PATH=/usr/share/colorgcc:/usr/share/colorgcc:/usr/bin:/bin:/usr/local/bin:/usr/X11R6/bin/:/usr/games:/usr/lib/qt4/bin:/usr/bin:/opt/kde3/bin:/usr/share/unsermake:/home/angelo/bin:/usr/share/unsermake
PIPESTATUS=([0]="0")
PO_BINS='po_extr64 po_subst64 po_compat64'
PO_COMPAT=no
PO_FROM_COMPAT=cat
PO_TO_COMPAT=cat
PPID=3237
PROFILEHOME=
PS4='+ '
PWD=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64/clip/tools
PYTHONDONTWRITEBYTECODE=1
PYTHONPATH=/usr/lib64/ooo-3.0.1_64/basis-link/program:/usr/lib64/ooo-3.0.1_64/basis-link/program
PYTHONSTARTUP=/etc/pythonrc.py
QT4DOCDIR=/usr/share/doc/qt4/doc
QTDIR=/usr/lib/qt4
QTINC=/usr/lib/qt3/include
QTLIB=/usr/lib64
QT_PLUGIN_PATH=/home/angelo/.kde4/lib64/kde4/plugins/:/usr/lib64/kde4/plugins/
QT_XFT=0
READLINE_LIBS='-lreadline -lncurses'
RFLAG=
SCREENDIR=/home/angelo/tmp
SCRIPTSUFF=64.sh
SECURE_LEVEL=3
SESSION_MANAGER=local/x86_64.angelo.girardi.home:@/tmp/.ICE-unix/21458,unix/x86_64.angelo.girardi.home:/tmp/.ICE-unix/21458
SHELL=/bin/bash
SHELLOPTS=braceexpand:hashall:interactive-comments:nounset
SHLVL=5
SSH_ASKPASS=/usr/lib64/ssh/ssh-askpass
STATICLINK=
STD_LIBDIR=
STD_LIB_DIR=/usr/lib64
SleepTime=0
StartTime=1247615073
StartTotal=1
TASK=libcliptask/libcliptask.a
TERM=xterm
TMP=/home/angelo/tmp
TMPDIR=/home/angelo/tmp
Total=1
TotalDone=1
TotalRemaining=1
UID=500
USER=angelo
USE_AS=no
USE_LD=yes
USE_MEMDBG=no
USE_TASKS=yes
USE_WCHARS=yes
V=v
WINDOWID=44040296
WINDOWPATH=7
WaitForCheck=y
XCLIP=
XDG_CONFIG_DIRS=/etc/xdg:/etc/xdg/kde4
XDG_DATA_DIRS=/usr/share:/opt/kde3/share
XDG_MENU_PREFIX=kde-
XDG_SESSION_COOKIE=92a1dfdcc49e52f25e0b5da84a45793f-1247576468.931826-1475283628
XDM_MANAGED=method=classic
XMODIFIERS=@im=none
_=/home/angelo//clip64//include/
arch=x86_64
dostrip=
fName=/usr/lib64
lList=/usr/lib64
option=home
opts=home
osname=LINUX
pwd=/sda1/source/compile/my_make.new/x86_64/clip-prg.32-64
reg=1
release=
uname=Linux
uver=2.6.29.6-desktop-1mnb
AllExpanded () 
{ 
    local lWord=$1;
    local lString=;
    local aString="";
    local aPos="";
    local ReturnString="";
    local lExtension=$2;
    local nii;
    local njj;
    local nkk;
    local nmm;
    local sii;
    local sjj;
    local lenPar;
    local nPos;
    local nChar;
    nChar=${#aAllCharacter[@]};
    nPos=0;
    lenPar=${#lWord};
    lString="";
    nii=0;
    while [ $nii -lt $lenPar ]; do
        aString[$nii]=${aAllCharacter[0]};
        lString="$lString${aString[$nii]}";
        aPos[$nii]=0;
        let ++nii;
    done;
    let njj=1;
    nPos=0;
    nii=0;
    nt=0;
    while [[ $lString$lExtension != $lWord ]] && [ $nii -lt $lenPar ]; do
        while [[ $lString$lExtension < $lWord ]] && [ $nPos -lt $nChar ]; do
            aPos[$nii]=$nPos;
            nt=$nii;
            let ++nPos;
            aString[$nii]=${aAllCharacter[$nPos]};
            lString="";
            nmm=0;
            while [ $nmm -le $nii ]; do
                lString="$lString${aString[$nmm]}";
                let ++nmm;
            done;
        done;
        if [[ $lString$lExtension = $lWord ]]; then
            continue;
        fi;
        if [ $nPos -lt $nChar ]; then
            nPos=${aPos[$nii]};
            aString[$nii]=${aAllCharacter[$nPos]};
            let ++nii;
            aString[$nii]=${aAllCharacter[0]};
            aPos[$nii]=0;
            nPos=0;
            lString="";
            nmm=0;
            while [ $nmm -le $nii ]; do
                lString="$lString${aString[$nmm]}";
                let ++nmm;
            done;
        fi;
        if [[ $lString$lExtension > $lWord ]]; then
            while [[ $lString$lExtension > $lWord ]] && [ $nPos -lt $nChar ] && [ $nii -lt $lenPar ]; do
                aPos[$nii]=$nPos;
                let ++nPos;
                aString[$nii]=${aAllCharacter[$nPos]};
                nmm=0;
                lString="";
                while [ $nmm -le $nii ]; do
                    lString="$lString${aString[$nmm]}";
                    let ++nmm;
                done;
            done;
        fi;
        if [ $nPos -gt $nChar ]; then
            let --nii;
            nPos=${aPos[$nii]};
            let ++nPos;
            aPos[$nii]=$nPos;
            aString[$nii]=${aAllCharacter[$nPos]};
            let ++nii;
            nPos=0;
            aPos[$nii]=$npos;
            aString[$nii]=${aAllCharacter[$nPos]};
        fi;
        lString="";
        nmm=0;
        while [ $nmm -le $nii ]; do
            lString="$lString${aString[$nmm]}";
            let ++nmm;
        done;
    done;
    echo $lString
}
AllLower () 
{ 
    local x=$1;
    local y;
    y=$(echo $x | tr "[:upper:]" "[:lower:]" );
    echo $y
}
AllUpper () 
{ 
    local x="$*";
    local y;
    y="$(echo $x | tr "[:lower:]" "[:upper:]" )";
    echo $y
}
Check_Bin () 
{ 
    local LogFile="$Clip_T_Dir/askbin.log";
    local WhatToFind;
    local Extension;
    local RequestedBy;
    local Important;
    local WhereToFind;
    local Found="";
    local PackName;
    local lList;
    local fName;
    local ArrayToFind;
    local IdxToFind;
    local CurIdx;
    local Comment;
    local CommentNr;
    local varX="N";
    unset ArrayToFind;
    SleepTime=0;
    WhatToFind=$1;
    shift;
    Extension=$1;
    shift;
    RequestedBy=$1;
    shift;
    Important=$1;
    Important=$(AllUpper $Important );
    if [[ $Important = YES ]] || [[ $Important = NO ]]; then
        echo "" > /dev/null;
    else
        error $*;
    fi;
    shift;
    WhereToFind=$1;
    shift;
    PackName="";
    let CommentNr=-1;
    IdxToFind=false;
    while [ -n "$*" ]; do
        if [ "$1" = "/" ]; then
            IdxToFind=true;
        else
            if [ $IdxToFind = true ]; then
                let ++CommentNr;
                Comment[$CommentNr]=$1;
            else
                PackName="$PackName $1";
            fi;
        fi;
        shift;
    done;
    OnScreen 0;
    if [ -z $WhatToFind ]; then
        error No parameter passed in calling function Check_Bin;
    fi;
    IdxToFind=0;
    if [ -f "$Clip_S_Dir/$WhatToFind/.set" ]; then
        CurIdx="$Clip_S_Dir/$WhatToFind/.set";
        lList="$(cat $CurIdx)";
        for fName in $lList;
        do
            if [[ x"$fName" != x"" ]]; then
                ArrayToFind[$IdxToFind]=$fName;
                OnScreen 2 Found : $WhatToFind requested by : $RequestedBy found in $fName;
                echo $fName > "$Clip_S_Dir/$WhatToFind/.set";
                echo $fName;
                return 0;
                let ++IdxToFind;
            fi;
        done;
    fi;
    if [ -n $WhereToFind ]; then
        ArrayToFind[$IdxToFind]=$WhereToFind;
        let ++IdxToFind;
    fi;
    ArrayToFind[$IdxToFind]=/usr/bin;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/sbin;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/usr/sbin;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/usr/local;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/opt;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/usr;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/opt;
    if [[ "$WaitForCheck" = [Yy] ]]; then
        let ++IdxToFind;
        ArrayToFind[$IdxToFind]=/;
    fi;
    if [[ $Extension != xyz ]]; then
        WhatToFindTmp=$WhatToFind$Extension;
        if [ -f $WhereToFind/$WhatToFindTmp ]; then
            Found="$WhereToFind";
        fi;
    fi;
    while [[ $varX = [nN] ]]; do
        CurIdx=0;
        while [ -z "$Found" ] && [ $CurIdx -le $IdxToFind ]; do
            WhereToFind=${ArrayToFind[$CurIdx]};
            if [[ "$WhereToFind" = "/" ]]; then
                banner Not Found;
                OnScreen 1 in : ${ArrayToFind[@]};
                OnScreen 2;
                tptptpt=0;
                while [ $tptptpt -le $CommentNr ]; do
                    OnScreen 0 ${Comment[$tptptpt]};
                    let ++tptptpt;
                done;
                beep_on;
                OnScreen 2 " Scan the all s[Y]stem : '$WhereToFind'";
                OnScreen 0 " or install package : $PackName ";
                OnScreen 0 " and [R]escan standard directories ";
                OnScreen 0 " or [N] skip : ";
                OnScreen 0 ${ArrayToFind[@]};
                OnScreen 2;
                varX=" ";
                read -n 1 -p "Your choice : [Y/N/R] : " varX 1>&0;
                if [[ $varX = [nN] ]]; then
                    let ++CurIdx;
                    continue;
                else
                    if [[ $varX = [rR] ]]; then
                        CurIdx=0;
                        continue;
                    else
                        if [[ $varX = [Yy] ]]; then
                            OnScreen 0;
                        else
                            let --CurIdx;
                            continue;
                        fi;
                    fi;
                fi;
            fi;
            OnScreen 0 Searching for : $WhatToFind in $WhereToFind requested by : $RequestedBy;
            if [ -f $WhereToFind/$WhatToFind ]; then
                Found=$WhereToFind;
            else
                Found=$(Check_Find $WhereToFind $WhatToFind );
            fi;
            let ++CurIdx;
        done;
        if [ -z "$Found" ]; then
            varX="Y";
            banner Missing 1>&0;
            OnScreen 0 Missing : $WhatToFind requested by : $RequestedBy "Package name(s)" : $PackName;
            echo "Missing : $WhatToFind requested by : $RequestedBy Package name(s) : $PackName" 1>&2;
            if [[ $Important = YES ]]; then
                echo "#" >> $LogFile;
                echo This package is REQUIRED >> $LogFile;
                echo "#" >> $LogFile;
            fi;
            echo Missing : $WhatToFind requested by : $RequestedBy >> $LogFile;
            for IdxToFind in $PackName;
            do
                echo "Package name(s)" : $IdxToFind >> $LogFile;
            done;
        else
            beep_on;
            OnScreen 2 Found : $WhatToFind requested by : $RequestedBy found in $Found;
            OnScreen 2 "[s]earch path";
            read -n 1 -p "Is it Ok [y/n/s] : " varX 1>&0;
            OnScreen 2;
            if [[ $varX = [yY] ]]; then
                mkdir -p$V "$Clip_S_Dir/$WhatToFind/";
                echo $Found > "$Clip_S_Dir/$WhatToFind/.set";
                echo $Found;
            else
                if [[ $varX = [sS] ]]; then
                    read -p "Search path : " varX 1>&0;
                    ArrayToFind[0]=$varX;
                    varX="N";
                    Found="";
                else
                    Found="";
                    echo "z" 1>&0;
                    varX="N";
                fi;
            fi;
        fi;
    done
}
Check_Find () 
{ 
    local WhereToFind=$1*;
    local WhatToFind=$2;
    local Found;
    local HaveFound;
    local nii;
    HaveFound=$(find $WhereToFind -name $WhatToFind -printf "%h ");
    Found="";
    for nii in $HaveFound;
    do
        if [ -z $Found ]; then
            Found=$nii;
        fi;
    done;
    echo $Found
}
Check_Include () 
{ 
    local LogFile="$Clip_T_Dir/askinclude.log";
    local WhatToFind;
    local Extension;
    local RequestedBy;
    local VariableToCreate;
    local Important;
    local WhereToFind;
    local Found="";
    local PackName;
    local ArrayToFind;
    local IdxToFind;
    local CurIdx;
    local Comment;
    local CommentNr;
    local varX="N";
    IdxToFind=0;
    unset ArrayToFind;
    WhatToFind=$1;
    shift;
    Extension=$1;
    shift;
    RequestedBy=$1;
    shift;
    Important=$1;
    Important=$(AllUpper $Important );
    if [[ "$Important" = YES ]] || [[ "$Important" = NO ]]; then
        echo "" > /dev/null;
    else
        error $*;
    fi;
    shift;
    WhereToFind=$1;
    shift;
    PackName="";
    let CommentNr=-1;
    IdxToFind=false;
    while [ -n "$*" ]; do
        if [ "$1" = "/" ]; then
            IdxToFind=true;
        else
            if [ $IdxToFind = true ]; then
                let ++CommentNr;
                Comment[$CommentNr]=$1;
            else
                PackName="$PackName $1";
            fi;
        fi;
        shift;
    done;
    OnScreen 0;
    if [ -z $WhatToFind ]; then
        error No parameter passed in calling function Check_Include;
    fi;
    IdxToFind=0;
    if [ -f "$Clip_S_Dir/$WhatToFind/.set" ]; then
        CurIdx="$Clip_S_Dir/$WhatToFind/.set";
        lList="$(cat $CurIdx)";
        for fName in $lList;
        do
            if [[ x"$fName" != x"" ]]; then
                ArrayToFind[$IdxToFind]=$fName;
                OnScreen 2 Found : $WhatToFind requested by : $RequestedBy found in $fName;
                echo $fName > "$Clip_S_Dir/$WhatToFind/.set";
                echo $fName;
                return 0;
                let ++IdxToFind;
            fi;
        done;
    fi;
    if [ -n $WhereToFind ]; then
        ArrayToFind[$IdxToFind]=$WhereToFind;
        let ++IdxToFind;
    fi;
    ArrayToFind[$IdxToFind]=/usr/local;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/opt;
    let ++IdxToFind;
    if [ -d /include ]; then
        ArrayToFind[$IdxToFind]=/include;
        let ++IdxToFind;
    fi;
    ArrayToFind[$IdxToFind]=/usr/include;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/usr;
    if [[ "$WaitForCheck" = [Yy] ]]; then
        let ++IdxToFind;
        ArrayToFind[$IdxToFind]=/;
    fi;
    if [[ $Extension != xyz ]]; then
        WhatToFindTmp=$WhatToFind$Extension;
        if [ -f $WhereToFind/$WhatToFindTmp ]; then
            Found=$WhereToFind;
        fi;
    fi;
    while [[ $varX = [nN] ]]; do
        CurIdx=0;
        while [ -z "$Found" ] && [ $CurIdx -le $IdxToFind ]; do
            WhereToFind=${ArrayToFind[$CurIdx]};
            if [[ "$WhereToFind" = "/" ]]; then
                banner Not Found;
                OnScreen 1 in : ${ArrayToFind[@]};
                OnScreen 2;
                tptptpt=0;
                while [ $tptptpt -le $CommentNr ]; do
                    OnScreen 0 ${Comment[$tptptpt]};
                    let ++tptptpt;
                done;
                beep_on;
                OnScreen 2 " Scan the all s[Y]stem : '$WhereToFind'";
                OnScreen 0 " or install package : $PackName ";
                OnScreen 0 " and [R]escan standard directories ";
                OnScreen 0 " or [N] skip : ";
                OnScreen 0 ${ArrayToFind[@]};
                OnScreen 2;
                varX=" ";
                read -n 1 -p "Your choice : [Y/N/R] : " varX 1>&0;
                if [[ $varX = [nN] ]]; then
                    let ++CurIdx;
                    continue;
                else
                    if [[ $varX = [rR] ]]; then
                        CurIdx=0;
                        continue;
                    else
                        if [[ $varX = [Yy] ]]; then
                            OnScreen 0;
                        else
                            let --CurIdx;
                            continue;
                        fi;
                    fi;
                fi;
            fi;
            OnScreen 0 Searching for : $WhatToFind in $WhereToFind requested by : $RequestedBy;
            if [ -f $WhereToFind/$WhatToFind ]; then
                Found=$WhereToFind;
            else
                Found=$(Check_Find $WhereToFind $WhatToFind );
            fi;
            let ++CurIdx;
        done;
        if [ -z "$Found" ]; then
            varX="Y";
            banner Missing 1>&0;
            OnScreen 0 Missing : $WhatToFind requested by : $RequestedBy 'Package name(s)' : $PackName;
            echo "Missing : $WhatToFind requested by : $RequestedBy Package name(s) : $PackName" 1>&2;
            if [[ $Important = YES ]]; then
                echo "#" >> $LogFile;
                echo This package is REQUIRED >> $LogFile;
                echo "#" >> $LogFile;
            fi;
            echo Missing : $WhatToFind requested by : $RequestedBy >> $LogFile;
            for IdxToFind in $PackName;
            do
                echo "Package name(s)" : $IdxToFind >> $LogFile;
            done;
        else
            beep_on;
            OnScreen 2 Found : $WhatToFind requested by : $RequestedBy found in $Found;
            OnScreen 2 "[s]earch path";
            read -n 1 -p "Is it Ok [y/n/s] : " varX 1>&0;
            OnScreen 2;
            if [[ $varX = [yY] ]]; then
                mkdir -p$V "$Clip_S_Dir/$WhatToFind/";
                echo $Found > "$Clip_S_Dir/$WhatToFind/.set";
                echo $Found;
            else
                if [[ $varX = [sS] ]]; then
                    read -p "Search path : " varX 1>&0;
                    ArrayToFind[0]=$varX;
                    Found="";
                    varX="N";
                else
                    Found="";
                    echo "z" 1>&0;
                    varX="N";
                fi;
            fi;
        fi;
    done
}
Check_Library () 
{ 
    local LogFile="$Clip_T_Dir/asklibrary.log";
    local WhatToFind;
    local Extension;
    local RequestedBy;
    local Important;
    local WhereToFind;
    local Found="";
    local PackName;
    local ArrayToFind;
    local IdxToFind;
    local CurIdx;
    unset ArrayToFind;
    local Comment;
    local CommentNr;
    local varX="N";
    WhatToFind=lib$1;
    shift;
    Extension=$1;
    shift;
    RequestedBy=$1;
    shift;
    Important=$1;
    Important=$(AllUpper $Important );
    if [[ $Important = YES ]] || [[ $Important = NO ]]; then
        echo "" > /dev/null;
    else
        error $*;
    fi;
    shift;
    WhereToFind=$1;
    shift;
    PackName="";
    let CommentNr=-1;
    IdxToFind=false;
    while [ -n "$*" ]; do
        if [ "$1" = "/" ]; then
            IdxToFind=true;
        else
            if [ $IdxToFind = true ]; then
                let ++CommentNr;
                Comment[$CommentNr]=$1;
            else
                PackName="$PackName $1";
            fi;
        fi;
        shift;
    done;
    OnScreen 0;
    if [ -z $WhatToFind ]; then
        error No parameter passed in calling function Check_Library;
    fi;
    IdxToFind=0;
    if [ -f "$Clip_S_Dir/$WhatToFind/.set" ]; then
        CurIdx="$Clip_S_Dir/$WhatToFind/.set";
        lList="$(cat $CurIdx)";
        for fName in $lList;
        do
            if [[ x"$fName" != x"" ]]; then
                OnScreen 2 Found : $WhatToFind requested by : $RequestedBy found in $fName;
                mkdir -p$V "$Clip_S_Dir/$WhatToFind/";
                echo $fName > "$Clip_S_Dir/$WhatToFind/.set";
                echo $fName;
                return 0;
                ArrayToFind[$IdxToFind]=$fName;
                let ++IdxToFind;
            fi;
        done;
    fi;
    if [ -n $WhereToFind ]; then
        ArrayToFind[$IdxToFind]=$WhereToFind;
        let ++IdxToFind;
    fi;
    ArrayToFind[$IdxToFind]=/usr/local;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/opt;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/$LibDir;
    let ++IdxToFind;
    ArrayToFind[$IdxToFind]=/usr/$LibDir;
    if [[ "$WaitForCheck" = [Yy] ]]; then
        let ++IdxToFind;
        ArrayToFind[$IdxToFind]=/;
    fi;
    if [[ $Extension != xyz ]]; then
        WhatToFindTmp=$WhatToFind$Extension;
        if [ -f $WhereToFind/$WhatToFindTmp ]; then
            Found=$WhereToFind;
        fi;
    fi;
    while [[ $varX = [nN] ]]; do
        CurIdx=0;
        while [ -z "$Found" ] && [ $CurIdx -le $IdxToFind ]; do
            WhereToFind=${ArrayToFind[$CurIdx]};
            if [[ "$WhereToFind" = "/" ]]; then
                banner Not Found;
                OnScreen 1 in : ${ArrayToFind[@]};
                OnScreen 2;
                tptptpt=0;
                while [ $tptptpt -le $CommentNr ]; do
                    OnScreen 0 ${Comment[$tptptpt]};
                    let ++tptptpt;
                done;
                beep_on;
                OnScreen 2 " Scan the all s[Y]stem : '$WhereToFind'";
                OnScreen 0 " or install package : $PackName ";
                OnScreen 0 " and [R]escan standard directories ";
                OnScreen 0 " or [N] skip : ";
                OnScreen 0 ${ArrayToFind[@]};
                OnScreen 2;
                varX=" ";
                read -n 1 -p "Your choice : [Y/N/R] : " varX 1>&0;
                if [[ $varX = [nN] ]]; then
                    let ++CurIdx;
                    continue;
                else
                    if [[ $varX = [rR] ]]; then
                        CurIdx=0;
                        continue;
                    else
                        if [[ $varX = [Yy] ]]; then
                            OnScreen 0;
                        else
                            let --CurIdx;
                            continue;
                        fi;
                    fi;
                fi;
            fi;
            OnScreen 0 Searching for : $WhatToFind.so in $WhereToFind requested by : $RequestedBy;
            if [ -f $WhereToFind/$WhatToFind.so ]; then
                Found=$WhereToFind;
            else
                Found=$(Check_Find $WhereToFind $WhatToFind.a );
            fi;
            if [ -z "$Found" ]; then
                OnScreen 0 Searching for : $WhatToFind.a in $WhereToFind requested by : $RequestedBy;
                if [ -f $WhereToFind/$WhatToFind.a ]; then
                    Found=$WhereToFind;
                else
                    Found=$(Check_Find $WhereToFind $WhatToFind.so );
                fi;
            fi;
            let ++CurIdx;
        done;
        if [ -z "$Found" ]; then
            varX="Y";
            banner Missing 1>&0;
            OnScreen 0 Missing : $WhatToFind requested by : $RequestedBy "Package name(s)" : $PackName;
            echo "Missing : $WhatToFind requested by : $RequestedBy Package name(s) : $PackName" 1>&2;
            if [[ $Important = YES ]]; then
                echo "#" >> $LogFile;
                echo This package is REQUIRED >> $LogFile;
                echo "#" >> $LogFile;
            fi;
            echo Missing : $WhatToFind requested by : $RequestedBy >> $LogFile;
            for IdxToFind in $PackName;
            do
                echo "Package name(s)" : $IdxToFind >> $LogFile;
            done;
        else
            beep_on;
            OnScreen 2 Found : $WhatToFind requested by : $RequestedBy found in $Found;
            OnScreen 2 "[s]earch path";
            read -n 1 -p "Is it Ok [y/n/s] : " varX 1>&0;
            OnScreen 2;
            if [[ $varX = [yY] ]]; then
                mkdir -p$V "$Clip_S_Dir/$WhatToFind/";
                echo $Found > "$Clip_S_Dir/$WhatToFind/.set";
                echo $Found;
            else
                if [[ $varX = [sS] ]]; then
                    read -p "Search path : " varX 1>&0;
                    ArrayToFind[0]=$varX;
                    Found="";
                    varX="N";
                else
                    Found="";
                    echo "z" 1>&0;
                    varX="N";
                fi;
            fi;
        fi;
    done
}
Config_Init () 
{ 
    rm -f$V ./Makefile ./Makefile.01 ./Makefile.ini ./configure.ini ./include || true;
    source ../configure.ini;
    if [ $? != 0 ]; then
        echo "Configuration for $PWD Config_Init";
        error $PWD;
        exit 1;
    fi;
    cp --remove-destination -uf$V ../configure.ini ./;
    cp --remove-destination -uf$V ../Makefile.ini ./;
    [ -d include ] || [ -L include ] || ln -sf$V $Clip_I_Dir ./include;
    [ -d locale.po ] || [ -L locale.po ] || ln -sf$V $CLIPROOT/locale.po ./locale.po;
    [ -d charsets ] || [ -L charsets ] || ln -sf$V $CLIPROOT/charsets ./charsets
}
Config_Init_2 () 
{ 
    source ./configure.ini;
    if [ $? != 0 ]; then
        echo "Configuration for $PWD Config_Init_2";
        error $PWD;
        exit 1;
    fi
}
CreateAllDirs () 
{ 
    Clip_C_Dir="$Clip_M_Dir/config";
    Clip_S_Dir="$Clip_C_Dir/setup";
    Clip_T_Dir="$Clip_M_Dir/temp";
    Clip_D_Dir="$CLIPROOT/doc";
    Hash_Dir="$Clip_M_Dir/hasher/hashed";
    [ -d $Clip_S_Dir ] || mkdir -p$V $Clip_S_Dir;
    [ -d $Clip_T_Dir ] || mkdir -p$V $Clip_T_Dir;
    [ -d $Clip_B_Dir ] || mkdir -p$V $Clip_B_Dir;
    [ -d $Clip_D_Dir ] || mkdir -p$V $Clip_D_Dir;
    [ -d $Clip_I_Dir ] || mkdir -p$V $Clip_I_Dir;
    [ -d $Clip_L_Dir ] || mkdir -p$V $Clip_L_Dir;
    [ -d $Hash_Dir ] || mkdir -p$V $Hash_Dir
}
CreateMakefile () 
{ 
    MkExist=0;
    if [ -f ./Makefile ]; then
        MkExist=1;
    fi;
    sleep .1;
    echo "# generated by configure" > Makefile;
    cat $Makefile_01_in >> Makefile;
    cat ./Makefile.ini >> Makefile;
    cat ./configure.ini > /dev/null;
    if [ $? != 0 ]; then
        echo "Configuration for $PWD";
        error $PWD;
        exit 1;
    fi;
    cat ./Makefile.01 >> Makefile;
    cat $Makefile_gen_in >> Makefile;
    cat ./Makefile.in >> Makefile;
    if [[ -MkExist = 1 ]]; then
        error $PWD/Makefile $0 EXISTS!!!;
    fi
}
ETAtime () 
{ 
    local Etime;
    local ElapsedTime;
    local TotalRemaining;
    local ToEcho;
    local Total;
    local TotalDone;
    local TTtimeDone;
    local TTtimeEtime;
    TotalDone=$1;
    Total=$2;
    if [ $TotalDone -le 0 ]; then
        let TotalDone=1;
    fi;
    let TotalRemaining=$Total-$TotalDone;
    let ElapsedTime=$(date +%s);
    let ElapsedTime=$ElapsedTime-$StartTime;
    let Etime=($TotalRemaining*$ElapsedTime);
    let Etime=$Etime/$TotalDone;
    let TTtimeDone=$ElapsedTime*2;
    let TTtimeEtime=$Etime*$lEtime;
    if [ $StartTotal -eq 0 ]; then
        let Etime=$Etime*$Etime;
        let ElapsedTime=$ElapsedTime*2;
        let Etime=$lEtime+$ElapsedTime;
        let Etime=$Etime/2;
    fi;
    ToEcho=$(SecToTime $Etime );
    echo ETA : $ToEcho
}
Execute_Command () 
{ 
    local Parameter="$1";
    local xy;
    local ToExecute="";
    local ArrayX;
    local ii;
    echo "Execute_Command : $*" >> tt.sh;
    let xy=-1;
    while ! [ -z "$Parameter" ]; do
        let ++xy;
        if [ "$Parameter" == "|" ]; then
            ArrayX[$xy]=' ';
        else
            ArrayX[$xy]=$Parameter;
        fi;
        shift;
    done;
    while [ $xy -ne -1 ]; do
        ii="${ArrayX[$xy]}$ToExecute";
        ToExecute="$ii";
        let --xy;
    done;
    echo $ToExecute >> tt.sh;
    $ToExecute
}
GetArch () 
{ 
    local yz;
    local xy;
    local ARCH="";
    local varX;
    local C64;
    local trt;
    local nii;
    xy=0;
    let yz=1;
    if [[ "1" = "$*" ]]; then
        let varX=-1;
    else
        varX="$*";
        [ -z "$varX" ] && varX=0;
    fi;
    if [ -f $Clip_S_Dir/ARCH.setup.ini ]; then
        ARCH=$(cat "$Clip_S_Dir/ARCH.setup.ini");
    fi;
    for nii in $ARCH;
    do
        ARCH=$nii;
    done;
    C64=$(uname -m);
    if [ -n "$ARCH" ]; then
        if [[ $ARCH = "x86_64" ]] && [[ $C64 = "x86_64" ]]; then
            let yz=2;
        else
            let yz=1;
        fi;
    else
        let yz=-1;
    fi;
    if [ $varX -eq -1 ]; then
        let yz=-1;
    fi;
    while [ $yz -eq -1 ]; do
        rm -fv$V $Clip_S_Dir/* 1>&0;
        rm -Rf$V $DESTDIR$CLIPROOT 1>&0;
        varX=0;
        OnScreen 10 "You may install :";
        OnScreen 1 "[ 1 ] : i386/i586 version ";
        if [[ "$C64" = "x86_64" ]]; then
            OnScreen 1 "if you want to compile for 32 bits, you NEED TO INSTALL 32 bits libraries";
            OnScreen 1 "[ 2 ] : x86_64 version ";
            OnScreen 0;
        fi;
        read -n 1 -p "			Your choice : " varX 1>&0;
        trt=$varX;
        if [ $trt -le 0 ]; then
            let trt=-1;
        else
            if [ $trt -gt 2 ]; then
                beep_on;
                let trt=-1;
            else
                if [ $trt -eq 2 ] && [[ $C64 = "x86_64" ]]; then
                    beep_on;
                fi;
            fi;
        fi;
        yz=$trt;
        if [ $yz -eq 2 ] && [[ $C64 = "x86_64" ]]; then
            ARCH=x86_64;
        else
            ARCH=i586;
        fi;
        echo $ARCH > $Clip_S_Dir/ARCH.setup.ini;
    done;
    if [ $yz -eq 2 ] && [[ $C64 = "x86_64" ]]; then
        ARCH=x86_64;
    else
        ARCH=i586;
    fi;
    echo $ARCH
}
MakeDocDir () 
{ 
    if [ -n $* ]; then
        [ -d $Clip_D_Dir/$1 ] || mkdir -p$V $Clip_D_Dir/$1;
        [ -d $Clip_D_Dir/example/$1 ] || mkdir -p$V $Clip_D_Dir/example/$1;
    fi
}
OnScreen () 
{ 
    local xx;
    local yy="$1";
    if ( [[ "$yy" < "A" ]] && [[ $yy -ge 0 ]] ); then
        xx=$yy;
        shift;
    else
        xx=0;
    fi;
    while [ $xx -gt 1 ]; do
        echo "" 1>&0;
        let --xx;
    done;
    echo $* 1>&0
}
ReadVarX_Min_Max () 
{ 
    local Values;
    local xx;
    local Message=$1;
    shift;
    local MinValue=$1;
    shift;
    local MaxValue=$1;
    shift;
    if [[ $MinValue != [0Nn] ]]; then
        error ReadVarX_Min_Max $*;
    fi;
    xy=0;
    while [ -n "$*" ]; do
        Values[$xy]=$1;
        let ++xy;
        shift;
    done;
    trt=-1;
    while [ $trt -gt $MaxValue ] || [ $trt -lt $MinValue ]; do
        OnScreen 0 $Message;
        read -n 1 -p " Values : [ $MinValue >> $MaxValue ] : " trt 1>&0;
    done;
    if [[ ${Values[$trt]} = "/" ]]; then
        echo "";
    else
        echo ${Values[$trt]};
    fi
}
SecToTime () 
{ 
    local lDays;
    local lHours;
    local lMinutes;
    local lSeconds;
    local lToEcho;
    lDays=0;
    lHours=0;
    lMinutes=0;
    lSeconds=$1;
    lToEcho=;
    while [ $lSeconds -ge 86400 ]; do
        let ++lDays;
        let lSeconds=$lSeconds-86400;
    done;
    if [ $lDays -gt 0 ]; then
        lToEcho="d$lDays";
    fi;
    while [ $lSeconds -ge 3600 ]; do
        let ++lHours;
        let lSeconds=$lSeconds-3600;
    done;
    if [ $lHours -gt 9 ] && [ -n $lToEcho ]; then
        lToEcho="$lToEcho.$lHours";
    else
        if [ $lHours -gt 0 ] && [ -n $lToEcho ]; then
            lToEcho="$lToEcho.0$lHours";
        else
            if [ -n $lToEcho ]; then
                lToEcho="$lToEcho.00";
            else
                if [ $lHours -gt 0 ]; then
                    lToEcho="$lHours";
                fi;
            fi;
        fi;
    fi;
    while [ $lSeconds -ge 60 ]; do
        let ++lMinutes;
        let lSeconds=$lSeconds-60;
    done;
    if [ $lMinutes -gt 9 ] && [ -n $lToEcho ]; then
        lToEcho="$lToEcho:$lMinutes";
    else
        if [ $lMinutes -gt 0 ] && [ -n $lToEcho ]; then
            lToEcho="$lToEcho:0$lMinutes";
        else
            if [ -n $lToEcho ]; then
                lToEcho="$lToEcho:00";
            else
                if [ $lMinutes -gt 0 ]; then
                    lToEcho="$lMinutes";
                fi;
            fi;
        fi;
    fi;
    if [ $lSeconds -gt 9 ] && [ -n $lToEcho ]; then
        lToEcho="$lToEcho:$lSeconds";
    else
        if [ $lSeconds -gt 0 ] && [ -n $lToEcho ]; then
            lToEcho="$lToEcho:0$lSeconds";
        else
            if [ -n $lToEcho ]; then
                lToEcho="$lToEcho:00";
            else
                lToEcho="$lSeconds s";
            fi;
        fi;
    fi;
    echo $lToEcho
}
StatusScreen () 
{ 
    echo $* 1>&0
}
TotalFiles () 
{ 
    local njj;
    local ljj;
    local lList;
    njj=0;
    echo Calculating ... 1>&0;
    ljj=$$;
    ls -AR > "$HOME/tmp$ljj";
    lList=$(cat "$HOME/tmp$ljj");
    rm -f ./tmp$ljj > /dev/null;
    for ljj in $lList;
    do
        let ++njj;
    done;
    lList=;
    echo $njj
}
allConfigure () 
{ 
    local ListFile;
    local nFile;
    local CurDir="$Clip_M_Dir/$*";
    cd "$CurDir";
    OnScreen 1 "Configuration for $PWD";
    export > /dev/null;
    [ -f $CONFIGURE_SH ] && $CONFIGURE_DIR $MAKECMDGOALS;
    [ $? != 0 ] && error $CurDir
}
arch_sh () 
{ 
    a="$HOSTTYPE";
    [ -z "$a" ] && a=`uname -m 2>/dev/null`;
    [ -z "$a" ] && a=`uname -p 2>/dev/null`;
    [ -z "$a" ] && a=unknown;
    case "$a" in 
        i?86)
            echo i386
        ;;
        *)
            echo $a
        ;;
    esac
}
banner () 
{ 
    if [[ "$Bban" != 0 ]]; then
        export Bban=0;
        Check_Bin banner xyz clip yes /usr/bin banner-xx-$ARCH.rpm;
    fi;
    if [ -x /usr/bin/banner ]; then
        /usr/bin/banner $* 1>&0;
    else
        echo $* 1>&0;
    fi
}
beep_on () 
{ 
    if [ -x /usr/bin/gnubeep ]; then
        echo " beep beep" 1>&0;
        /usr/bin/gnubeep -b;
    else
        if [ -x /usr/bin/mplayer ]; then
            echo " beep mplayer beep" 1>&0;
            echo "" 1>&0;
        else
            if [ -x /usr/bin/play ]; then
                echo " beep play beep" 1>&0;
                echo "" 1>&0;
            else
                echo " beep beep" 1>&0;
                echo "" 1>&0;
            fi;
        fi;
    fi
}
create_var () 
{ 
    local yName;
    yName=$1;
    shift;
    if [ -n "$*" ]; then
        $yName="$*";
    fi;
    export > /dev/null
}
deception () 
{ 
    if [ -x /usr/bin/mplayer ]; then
        echo " pitty mplayer pitty" 1>&0;
        echo "" 1>&0;
    else
        if [ -x /usr/bin/play ]; then
            echo " pitty play pitty" 1>&0;
            echo "" 1>&0;
        else
            echo " pitty pitty" 1>&0;
            echo "" 1>&0;
        fi;
    fi
}
error () 
{ 
    OnScreen 1 "...............error..............";
    OnScreen 1 "...............error..............";
    OnScreen 0;
    while [ -n "$*" ]; do
        OnScreen 0 error : $1;
        shift;
    done;
    deception;
    warning ".........error.........breaking !!!!";
    read -p "Press <enter> to continue"
}
libcver () 
{ 
    local GLIBC;
    local GLIBC_MINOR;
    local GNU_LIBRARY;
    GLIBC=$(grep '^#define[ 	]*__GLIBC__' /usr/include/features.h 2>/dev/null | tr -s ' 	' ' ' | cut -d' ' -f3);
    GLIBC_MINOR=$(grep '^#define[ 	]*__GLIBC_MINOR__' /usr/include/features.h 2>/dev/null | tr -s ' 	' ' ' | cut -d' ' -f3);
    GNU_LIBRARY=$(grep '^#define[ 	]*__GNU_LIBRARY__' /usr/include/features.h 2>/dev/null | tr -s ' 	' ' ' | cut -d' ' -f3);
    if [ -n "$GLIBC" -a -n "$GLIBC_MINOR" ]; then
        echo "glibc$GLIBC.$GLIBC_MINOR";
    else
        if [ -n "$GNU_LIBRARY" ]; then
            echo "libc$GNU_LIBRARY";
        else
            name="$(uname -r|cut -d '(' -f 1)";
            if [ -n "$name" ]; then
                echo "$name";
            else
                echo "libc_unknown";
            fi;
        fi;
    fi
}
oneof () 
{ 
    for i in $*;
    do
        if [ -f $i ]; then
            echo $i;
            return 0;
        fi;
    done
}
oneofdir () 
{ 
    for i in $*;
    do
        if [ -d $i ]; then
            echo $i;
            return 0;
        fi;
    done;
    return 0
}
osname () 
{ 
    local uname;
    local osname;
    local rname;
    uname=`uname -s 2>/dev/null`;
    osname=$uname;
    case "$uname" in 
        BSD/OS* | bsdi*)
            osname=BSDI
        ;;
        [lL]inux*)
            osname=LINUX
        ;;
        FreeBSD*)
            osname=FREEBSD;
            STATICLINK=-static
        ;;
        NetBSD*)
            osname=NETBSD
        ;;
        OpenBSD*)
            osname=OPENBSD
        ;;
        SunOS*)
            osname=SUNOS;
            rname=`uname -r 2>/dev/null`;
            case "$rname" in 
                "5.7")
                    osname=SOLARIS_7
                ;;
                "5.8")
                    osname=SOLARIS_8
                ;;
                "5.9")
                    osname=SOLARIS_9
                ;;
            esac
        ;;
        CYGWIN*)
            osname=CYGWIN
        ;;
    esac;
    echo $osname
}
readans () 
{ 
    local ans;
    if [ -z "$yesf" ]; then
        printf "$1 [$2]: " 1>&2;
        read ans 0<&2;
    else
        echo "$1 [$2]:" 1>&2;
    fi;
    if [ -n "$ans" ]; then
        echo $ans;
    else
        echo $2;
    fi
}
temp_file () 
{ 
    Temp_File_Name=$Clip_T_Dir/temp.$Temp_File_Number;
    let ++Temp_File_Number;
    echo $Temp_File_Name
}
trumpet () 
{ 
    if [ -x /usr/bin/mplayer ]; then
        mplayer -vo null $Clip_M_Dir/sounds/k3b_success1.wav & echo " successful mplayer" 1>&0;
        echo "" 1>&0;
    else
        if [ -x /usr/bin/play ]; then
            play -ao alsa $Clip_M_Dir/sounds/k3b_success1.wav & echo " successful play " 1>&0;
            echo "" 1>&0;
        else
            echo " successful" 1>&0;
            echo "" 1>&0;
        fi;
    fi
}
warning () 
{ 
    OnScreen 1 "WARNING !!!";
    OnScreen 0;
    while [ -n "$*" ]; do
        OnScreen $1;
        shift;
    done;
    beep_on;
    OnScreen 1 ".................press any key";
    OnScreen 0;
    read -n 1 y 1>&0;
    OnScreen 0
}
xoneof () 
{ 
    for i in $*;
    do
        if [ -x $i ]; then
            echo $i;
            return 0;
        fi;
    done;
    return 0
}
